Qs How does introducing new clients affect this
   if client stalls on recieve response

paxos
  id
  state // init as undefined
  seq // undefined
  current_proposal // undefined
  accepted_seq // only used to determine commits

  function send_proposal
    return if this.state === 'undefined' or this.current_proposal !== 'undefined'
    current_proposal = {start_time: <current time>, total: peers.length, promise: [], reject: [], response_tuples: [{state: this.state, seq: this.seq}]}
    seq=(current_proposal['start_time'], this.id) // tuple, for absolute uniqueness
    comm get peers
    peers.each
      comm send('PROPOSE', (state, seq))

  function recieve_proposal(proposal)
    comm recieve proposal
    if proposal.seq > this.seq
      comm send('RESPONSE', accept: true, state: this.state, seq: this.seq) // undefined state & seq if it hasn't accepted anything yet
      this.accepted_seq = proposal.seq
    else
      comm send('RESPONSE', accept: false, state: this.state, seq: this.seq) // this is important because this is how newest states are communicated to old proposals

  function receive_response(response) // and choose to commit
    return if this.current_proposal === 'undefined'
    if current_time > this.current_proposal['start_time'] + 3 // end current proposal
      current_proposal = undefined
      return
    current_proposal['promise']++ if response.accept? == true
    current_proposal['reject']++ if response.accept? == false
    current_proposal['response_tuples'] << response_tuple
    if majority_met? or all_recieved
      if promises > rejections
        comm send 'COMMIT', current_proposal['response_tuples'].max

  function recieve_commit(proposal)
    if proposal.seq > this.seq && proposal.seq > this.accepted_seq
      this.state = proposal.state
      this.seq = proposal.seq
